using Serialization, MCMCChains

"""

combine\\_subchains(n\\_ensemble: Int64, n\\_walkers:Int64, n\\_iterations:Int64, n\\_subchains:Int64, approach: String, thin: Int64)

Appends all iterations of each emcee walker, saving every n=thin samples \n 
Save every n samples for more efficient storage and loading of chain \n
Save as an MCMCChains.Chain so that we can later use MCMCChains convergence diagnostics \n
Exclude first 1000 samples of each chain as burn-in \n

Should *save*: \n
MCMCChains.Chain: n\\_parameters, n\\_walkers (chains), and (n\\_iterations*n\\_subchains)/thin samples per parameter per walkers

"""

function combine_subchains(n_ensemble, n_walkers, n_iterations, n_subchains, approach, thin)
    #load named tuple that was generated by @timed macro. Entries include value (value returned by expression, here, mcmc chain)
    c0 = deserialize(string("outputs/posterior_samples_$(approach)_ensemble$(n_ensemble)_walkers$(n_walkers)_iter$(n_iterations)_1.jls"));
    #select only chain samples; dim are iter x parameters x chains. First value is for the @timed named tuple, next value and data are for indexing MCMCChain object
    c0 = c0.value
    parameter_names = [String(MCMCChains.names(c0)[i]) for i in 1:length(MCMCChains.names(c0))][1:end-1] #exclude lp
    #convert samples to array, returns array of iter x parameters x chains
    plain_samples = Base.stack(Array(c0, append_chains=false))[1:thin:end,:,:]
    #load rest of chains and append to 
    for i in 2:n_subchains
        temp_c = deserialize(string("outputs/posterior_samples_$(approach)_ensemble$(n_ensemble)_walkers$(n_walkers)_iter$(n_iterations)_$(i).jls")).value; #load additional n_iterations samples and convert to pure array
        temp_c = Base.stack(Array(temp_c, append_chains=false))[1:thin:end,:,:]
        plain_samples = vcat(plain_samples, temp_c) #concatenate additional samples to existing samples
    end
    mcmc_chain = Chains(plain_samples, parameter_names);
    serialize(string("outputs/004_posterior_samples_$(approach)_ensemble$(n_ensemble)_walkers$(n_walkers)_iter$(Int(n_iterations*n_subchains))_thinned$(thin).jls"),mcmc_chain);
end

"""
delete\\_subchains(n\\_ensemble: Int64, n\\_walkers:Int64, n\\_iterations:Int64, n\\_subchains:Int64, approach: String, thin: Int64)

Delete subchains. WARNING: run only after combine_subchains\n 

"""
function delete_subchains(n_ensemble, n_walkers, n_iterations, n_subchains, approach, thin)
    for i in 1:n_subchains
        Base.rm("outputs/posterior_samples_$(approach)_ensemble$(n_ensemble)_walkers$(n_walkers)_iter$(n_iterations)_$(i).jls")
    end
end